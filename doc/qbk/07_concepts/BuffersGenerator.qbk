[/
    Copyright (c) 2016-2022 Vinnie Falco (vinnie dot falco at gmail dot com)

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

    Official repository: https://github.com/boostorg/beast
]

[section:BuffersGenerator BuffersGenerator]

A [*BuffersGenerator] provides a generalized interface for generating
serialized data for sequential processing.

The generator will be asked to produce buffers. The consuming code will signal
how much of the data has been consumed, and repeatedly query for buffers until
no more data is available, or the generator indicates an error condition.

In this way, serializers can be adapted as [*BuffersGenerator], for example
__message_generator__ which provides a type-erased interface for a variety of
concrete http message types.

Overloads of `write` and `async_write` operations are provided as free
functions. These operations will consume the output of a [*BuffersGenerator]
and process the data by writing them to a __SyncWriteStream__ or
__AsyncWriteStream__ respectively.

[heading Associated Types]

* [link beast.ref.boost__beast__core__is_buffers_generator `is_buffers_generator`]
* __ConstBufferSequence__

[heading Requirements]

[warning
    These requirements may undergo non-backward compatible
    changes in subsequent versions.
]

In this table:

* `G` denotes a type meeting the requirements of [*BuffersGenerator].
* `g` denotes a value of type `G`.
* `n` is a value of type `std::size_t`.
* `ec` is a value of type [link beast.ref.boost__beast__error_code `error_code&`].

[table Valid expressions
[[Expression] [Type] [Semantics, Pre/Post-conditions]]
[
    [`G::const_buffers_type`]
    [`implementation-defined`]
    [
        A type which meets the requirements of __ConstBufferSequence__.
        This is the type of buffer returned by `g.prepare(ec)`.
    ]
][
    [`g.prepare(ec)`]
    [`G::const_buffers_type`]
    [
        Called to ask the generator to produce buffers containing data for processing.

        [*Note:] any buffers obtained by previous calls to `prepare` are
        invalidated.
        
        The (maximum) capacity of the buffer returned is defined by the
        generator implementation.

        Whether additional buffers are generated when unconsumed data is
        already available at the time of the call is defined by the implementation.

        The returned value is the __ConstBufferSequence__ of type `b`
        representing unconsumed data.

        If the total size of the buffers in the returned sequence is `0`, the
        generator is considered to have completed.

        The function will ensure that `!ec` is `true` if there was
        no error or set to the appropriate error code if there was one. 

        The result of invoking `prepare` again after completion or encountered
        error(s) is defined by the generator implementation. It can not be
        assumed to be meaningful or safe to do so, in general.
    ]
][
    [`g.consume(n)`]
    [`void`]
    [
        This function is called to signal that the consumer (caller) of the
        generator has processed part of the data returned by the previous call
        to `prepare`.

        The value of `n` is allowed to exceed the number of bytes returned from
        the last call to `prepare`, in which case the call to `consume` shall
        behave as if `n` was equal to that number.

        Any previously generated data that has not yet been `consume`d will
        be returned from subsequent calls to `prepare`.
    ]
][
    [`is_buffers_generator<G>`]
    [`std::true_type`]
    [
        An alias for `std::true_type` for `G`, otherwise an alias
        for `std::false_type`.
    ]
]]

[heading Exemplar]

```
    // A buffer sequence generator
    struct BuffersGenerator
    {
        using const_buffers_type = __implementation_defined__; /*<- no idea how to express this in a compiled snippet ->*/

        const_buffers_type prepare( error_code& ec );
        void consume( std::size_t n );
    };

    static_assert(
        is_buffers_generator<BuffersGenerator>::value, "");
```

[heading Models]

* [link beast.ref.boost__beast__http__message_generator `message_generator`]

[endsect]
